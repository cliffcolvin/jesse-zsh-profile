# Update git aliases
# Save a copy of the current aliases to a temporary file with a timestamp
cp ~/.aliases /tmp/.aliases-"$(date +%d-%m-%Y-%H-%M-%S)"
# Download the latest version of the.aliases file from GitHub
wget https://raw.githubusercontent.com/jessegoodier/jesse-zsh-profile/main/.aliases -O ~/.aliases
# Reload the Oh My Zsh configuration
omz reload

# Unalias the ksd command, which is a Kubernetes dashboard shortcut
unalias ksd 2>/dev/null

# Aliases
# List files in long format with hidden files and directories, and colorize the output
alias ll='ls -lah'
# Show the command history
alias h='history'
# Get information about Kubernetes resources
alias kg='kubectl get'
# Get nodes with labels
alias kgnol='kubectl get nodes --show-labels'
# Get endpoints
alias kgep='kubectl get ep'
# Describe a resource
alias kd='kubectl describe'
# Edit a StatefulSet
alias kests='kubectl edit sts'
# Find the image used in a pod
alias kdpi='kubectl describe pod|ag image:'
# Restart a deployment
alias krrd='kubectl rollout restart deployment'
# Restart a StatefulSet
alias krrsts='kubectl rollout restart sts'
# Get a list of StatefulSets
alias kgsts="kubectl get sts"
# Delete a StatefulSet
alias kdelsts="kubectl delete sts"

# Kubecost
# Get the logs for the cost-model container in the cost-analyzer pod
alias klcm="kubectl logs -l app=cost-analyzer --tail=-1 -c cost-model"
# Get the logs for the cost-analyzer-frontend container in the cost-analyzer pod
alias klfe="kubectl logs -l app=cost-analyzer --tail=-1 -c cost-analyzer-frontend"
# Get the logs for the aggregator container in the aggregator pod
alias kla="kubectl logs -l app=aggregator -c aggregator --tail=-1"
# Get the logs for the cost-model container in the cost-analyzer pod, and follow the logs
alias klcmf="kubectl logs -l app=cost-analyzer -c cost-model --tail=-1 --follow"
# Get the logs for the cost-analyzer-frontend container in the cost-analyzer pod, and follow the logs
alias klfef="kubectl logs -l app=cost-analyzer -c cost-analyzer-frontend --tail=-1 --follow"
# Get the logs for the aggregator container in the aggregator pod, and follow the logs
alias klaf="kubectl logs -l app=aggregator -c aggregator --tail=-1 --follow"

# Todo function to find the deployment
# Find the deployment named kubecost-cost-analyzer and execute the given command in the cost-analyzer-frontend container
alias kexecfe="kubectl exec -i -t deployment/kubecost-cost-analyzer -c cost-analyzer-frontend --" $1
# Find the deployment named kubecost-cost-analyzer and execute the given command in the cost-model container
alias kexeccm="kubectl exec -i -t deployment/kubecost-cost-analyzer -c cost-model --" $1

# Clean up unused images
# Remove any images that are not currently being used
alias drmi='docker rmi -f $(docker images -q)'
# Start a shell inside a container
alias deit='docker exec -i -t'

# Azure
# List all AKS clusters
alias azl='az aks list --output table'

# AWS
# List all EKS clusters
alias eks='eksctl get cluster'

# Randoms
# Clear the terminal screen
alias c='clear'
# Pipe the output of cat through ccat, which adds color and formatting to the output
alias cat='ccat'
# Send five ICMP ECHO_REQUEST packets and stop
alias ping='ping -c 5'
# Send 100 ICMP ECHO_REQUEST packets with a packet size of 0.2 seconds and do not wait one second between packets
alias fastping='ping -c 100 -s.2'
# Open a file with sudo permissions
alias svi='sudo vi'
# Pass options to the free command, such as showing memory usage in large units, showing the load average, and sorting by memory usage
alias meminfo='free -m -l -t'

# Get the top 5 processes by memory usage
alias psmem='ps auxf | sort -nr -k 4'
# Get the top 10 processes by memory usage
alias psmem10='ps auxf | sort -nr -k 4 | head -10'

# Get the top 5 processes by CPU usage
alias pscpu='ps auxf | sort -nr -k 3'
# Get the top 10 processes by CPU usage
alias pscpu10='ps auxf | sort -nr -k 3 | head -10'

# Get server CPU information
alias cpuinfo='lscpu'
# List the contents of the current directory in human-readable format and show the size of each file in KB, MB, GB, etc.
alias df='df -H'
# List the contents of the current directory in sorted order by size, and for each file, show the size in KB, MB, GB, etc.
alias du='du -sk * | sort -n | while read size fname; do for unit in k M G T P E Z Y; do if [ $size -lt 1024 ]; then echo -e "${size}${unit}\t${fname}"; break; fi; size=$((size/1024)); done; done'

# If exa is installed, use it as the default ls command, with colorized output, icons, and additional information such as file type
if [ "$(command -v exa)" ]; then
  alias ll='exa -l --color always --icons -a -s type'
  alias l='exa --color always --icons -a -s type'
  alias la='exa -l --color always --icons -a -s type'
  alias ls='exa -G  --color auto --icons -a -s type'
fi

# Use grep with colorized output and exclude certain directories, such as.bzr, CVS,.git,.hg,.svn,.idea,.tox,.vscode-server-insiders,.vscode-server,.vscode-server-insiders, and.vs-kubernetes
alias grep='grep --color=auto --exclude-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox,.vscode-server-insiders,.vscode-server,.vscode-server-insiders,.vs-kubernetes}'
# Use ack with colorized output and exclude the same directories as grep
alias ack='ack --color --ignore-dir={.bzr,CVS,.git,.hg,.svn,.idea,.tox,.vscode-server-insiders,.vscode-server,.vscode-server-insiders,.vs-kubernetes}'

# More Kubernetes
# Get information about Kubernetes resources
alias kg='kubectl get'
# Get persistent volumes
alias kgpv='kubectl get pv'
# Watch persistent volumes
alias kgpvw='kubectl get pv --watch'
# Watch all pods in all namespaces
alias kgpaw='kubectl get pods --all-namespaces --watch'
# Watch all pods in the current namespace
alias kgpw='kubectl get pods --watch'
# Set the current namespace
alias kn='kubectl config set-context --current --namespace'
# Use a specific Kubernetes context
alias kc='kubectl config use-context'
# If kubectx is installed, use it as an alternative to kn and kc
if [ "$(command -v kubectx)" ]; then
  alias kn='kubens'
  alias kx='kubectx'
fi

# Get a list of StatefulSets
alias kgsts="kubectl get sts"
# Get events, sorted by lastTimestamp, and only show events of type Normal
alias kge="kubectl get events --sort-by=lastTimestamp --field-selector type!=Normal"
# Start a shell inside a container
alias keit='kubectl exec -i -t'
# Get the nginx version running in the nginx-ingress namespace
alias kic="keit -n nginx-ingress \$(kgpn nginx-ingress|grep ingress -m1 |awk '{print \$1}') -- nginx -T | grep '\\S'"


# AWS
alias acreds='aws eks update-kubeconfig --region ca-central-1 --name'
# gcloud
# create a cluster
alias gccc='gcloud container clusters create --machine-type e2-standard-4 --num-nodes=1 --zone=us-east1-d --network=creynold-vpc'
# get kube creds for a cluster: gcreds jesse-gk1
gcreds() { ZONE=$(gcloud container clusters list --filter=name:"$1" --format="[no-heading](location)") ; gcloud container clusters get-credentials $1 --zone $ZONE }
#delete a cluster
gccd() { ZONE=$(gcloud container clusters list --filter=name:"$1" --format="[no-heading](location)") ; gcloud container clusters delete $1 --zone $ZONE $2 }
# list all clusters in our project, ignore cluster upgrade and surveys
alias gccl='gcloud container clusters list 2>/dev/null'
alias gcclj='gcloud container clusters list 2>/dev/null --filter=name:jesse --format="(name,location,currentNodeCount)"'
# resize cluster
gccr() { ZONE=$(gcloud container clusters list --filter=name:"$1" --format="[no-heading](location)") ; gcloud container clusters resize $1 --zone $ZONE --num-nodes $2 --quiet}
alias gcdu='gcloud dns record-sets update --type=A --ttl=30 --zone=nginx-rocks --rrdatas'
alias gccil'=gcloud compute instances list |grep jesse'
alias gil'=gcloud compute instances list |grep jesse'


k-get-all-images() {# Loop through each context
for context in $contexts; do
    echo "Context: $context"
    kubectl config use-context $context

    namespaces=$(kubectl get namespaces -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')

    # Loop through each namespace and print the image name of each pod
    for namespace in $namespaces; do

        # Get all pods in the current namespace
        pods=$(kubectl get pods -n $namespace -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')

        # Loop through each pod and print its image name
        for pod in $pods; do
            image=$(kubectl get pod $pod -n $namespace -o jsonpath='{.spec.containers[*].image}')
            echo "Context: $context, Namespace: $namespace, Pod: $pod, Image: $image"
        done

    done
done }

k-remove-bad-contexts() { # remove dead contexts
cp ~/.kube/config ./kubeconfig-"`date +"%d-%m-%Y-%H-%M-%S"`"
contexts=$(kubectl config get-contexts -o name)

# Loop through each context
for context in $contexts; do
    echo "Context: $context"
    kubectl config use-context $context

    # Check if the context is working
    if kubectl get pods &> /dev/null; then
        echo "Context $context is working"
    else
        echo "Context $context is not working"
        kubectl config delete-context $context
        echo "--------------Context $context has been removed------------------"
    fi

    echo ""
done }

function kgc {
# k get containers, show failures

# get the namespace from the first argument, otherwise use the current namespace
NAMESPACE=$1

if [[ -z "$NAMESPACE" ]]; then
  NAMESPACE=$(kubectl config view --minify --output 'jsonpath={..namespace}')
fi
echo "NAMESPACE: $NAMESPACE"

# If CURRENT_FAILURES is not declared or not an array, declare it as an array
if [ -z "${CURRENT_FAILURES+x}" ] || ! declare -p CURRENT_FAILURES 2> /dev/null | grep -q '^declare -a'; then
  declare -a CURRENT_FAILURES
fi

# Get all pods in the namespace
pods=($(kubectl get pods -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}'))

# Print table header
printf "%-50s %-30s %-10s\n" "Pod" "Container Name" "Container Status"

# Loop over pods
for pod in $pods; do

  # Get container statuses for each pod
  pod_container_statuses=($(kubectl get pod "$pod" -n "$NAMESPACE" -o jsonpath='{.status.containerStatuses}'))
  container_list=($(echo "$pod_container_statuses" | jq -r '.[].name'))

  # Loop over container statuses
  for container_name in $container_list; do

    container_status=$(echo "$pod_container_statuses" | jq -r ".[] | select(.name == \"$container_name\") |.state| keys[0]")

    # Print table row
    if [ "$container_status" != "running" ]; then
      printf "\033[0;31m%-50s %-30s %-10s\033[0m\n" "$pod" "$container_name" "$container_status"
      # Append $pod to the array
      CURRENT_FAILURES+=("$pod")
    else
      printf "%-50s %-30s %-10s\n" "$pod" "$container_name" "$container_status"
    fi

  done
done

# Print any pods with failing containers
if [[ ${#CURRENT_FAILURES[@]} -gt 0 ]]; then
  printf "\nPods with failing containers:\n"
  for pod in "${CURRENT_FAILURES[@]}"; do
    printf "\033[0;31m%s\033[0m\n" "$pod: $(get-failure-events-for-resource $pod)"
  done
fi


# Get all ReplicaSets in JSON format
replica_sets=$(kubectl get replicaset -n $NAMESPACE -o json)

# Use jq to filter ReplicaSets where '.status.replicas' (current) is less than '.spec.replicas' (desired)
replica_sets_with_unavailable_replicas=($(jq -r '.items[] | select(.status.replicas <.spec.replicas) |.metadata.name' <<< "$replica_sets"))

# Print any unavailable ReplicaSets
if [[ ${#replica_sets_with_unavailable_replicas[@]} -gt 0 ]]; then
  printf "\nUnavailable ReplicaSets:\n"
  for replica_set in $replica_sets_with_unavailable_replicas; do
    printf "\033[0;32m%s\033[0m: \033[0;36m%s\033[0m\n" "$replica_set" "$(get-failure-events-for-resource $replica_set)"
  done
fi
}
function get-failure-events-for-resource() {
  kubectl get events --sort-by=lastTimestamp --field-selector type!=Normal,involvedObject.name=$1 -ojson|jq -r '.items.[].message'
}